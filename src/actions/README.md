# Actions

[Back to CONTRIBUTING.md](../../../CONTRIBUTING.md)

Actions are the only functions in the codebase that are allowed to mutate the store.

Most actions will perform an http request where the method will be `POST/DELETE/PATCH`.

`GET` are generally done by the fetcher so they get automatically deduped across views
and can rely on the store to act like a big cache.

For standard `POST/DELETE/PATCH` use the functions defined in `helpers.ts`.

## Custom `GET`

Actions can either mutate the store synchronously - for view local state for instance -
or they do so asynchronously. Anytime you mutate the store put your mutations in an
`action` function like so:

```ts
import { action } from 'mobx';
import { Observable, tap } from 'rjxs';
import { ajax, AjaxError } from 'rxjs/ajax';
import { MAS_HEADERS } from '@/backend/headers';

// Asynchronous function that fetch some data on the MAS
export function getSomething(arg1: string): Observable<any> {
    const endpoint = `/api/v2/some/path/${arg1}/`;

    return ajax.getJSON(endpoint, MAS_HEADERS()).pipe(

        // Tap gets called if anyone is subscribing to the observable.
        // It does not change the content of the observable. It's a way
        // to perform side effect whenever an event is emitted.
        tap(
            // In this example, we don't do anything on the success path.
            undefined,

            // If there is a failure we put it into the store. Note the call to action here.
            action((err: AjaxError) => {
                //  ^~~
                //     Error here is an AjaxError generated by the ajax.getJSON call.
            }),
        ),
    );
}
```

A more complete example would also use a schema and validate the correctness in case of success.

For this we need to:

 1. Define a new schema doing the validation (if there's none matching our problem) in `@/backend/schemas`
 2. Import the `map` operator from `rxjs` and our `schema`.
 3. Update our code

See below for the code above updated:

```ts
import { action } from 'mobx';
import { Observable } from 'rxjs';
import { tap, map } from 'rxjs/operators';
import { ajax, AjaxError } from 'rxjs/ajax';
import { store } from '@/store';
import { mySchema } from '@/backend/schemas';
import { MAS_HEADERS } from '@/backend/headers';

// Asynchronous function that fetch some data on the MAS
export function getSomething(arg1: string): Observable<{ Prop: string }> {
    const endpoint = `/api/v2/some/path/${arg1}/`;

    return ajax.getJSON(endpoint, MAS_HEADERS()).pipe(

        // Tap gets called if anyone is subscribing to the observable.
        // It does not change the content of the observable. It's a way
        // to perform side effect whenever an event is emitted.
        tap(
            // In this example, we don't do anything on the success path.
            undefined,

            // If there is a failure we put it into the store. Note the call to action here.
            action((err: AjaxError) => {
                //  ^~~
                //     Error here is an AjaxError generated by the ajax.getJSON call.
                store.view.errors.httpErrors.push({ statusCode: err.status, endpoint });
            }),
        ),
        map(val => mySchema(val)),
        map(val => {
            if (val.type === 'error') {
                action(() => {
                    store.view.errors.schemaErrors.push({
                        endpoint,
                        reason: val.reason,
                        path: val.path,
                    });
                })();

                // We don't have to throw the error we could provide a default value.
                throw new Error(val.reason);
            }
            return val.value;
        }),
    );
}
```

In this case here is the schema that was used:

```ts
export const mySchema = defineSchema({
    Prop: String,
});
```

## Standard `POST` / `DELETE` / `PATCH`

If you make a standard `POST` / `DELETE` / `PATCH` it's best to use the helpers
as they do everything needed to let the other views knows that there is a problem.

Also because they're shared with most actions, improving them make the overall UI
(and UX) better with little effort.

Here is an example of an action using the post (with `FormData`):

```ts
import { postStdMasResponse } from './helpers';

export function submitForm(formData: FormData) {
    const endpoint = `/api/v2/some/path`;

    return postStdMasResponse(endpoint, formData);
}
```

With `JSON`:

```ts
import { postJSONStdMasResponse } from './helpers';

export function submitJSON(pojo: {}) {
    const endpoint = `/api/v2/some/path`;

    return postJSONStdMasResponse(endpoint, pojo);
}
```
